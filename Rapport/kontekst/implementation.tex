\chapter{Implementation}
Introduction to the chapter!

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.35]{billeder/compilerStructure}
\caption{Compiler structure}
\label{cs}
\end{figure}


\section{ANTLR}
Antlr og vores grammer(Tjek om vores grammar er beskrevet før)
Hvad gør antlr for os ?
Den får vores grammar og vores sourcecode, hvad gør den så ?


Forklar hvordan lexer, parser og hvordan antlr gør det. Sådan set de to første steps i diagrammet. Med deres output i form af Tokens og Parse tree.

Forklar de to visitor patterns som antlr genererer(Listener/walker og visitor)
\section{Function Definition}
After Antlr has produced the parsetree, baselistener and basevisitior, the function definition phase starts. In this phase every function that allready exists in Robocode, will be mapped to the names defined in the apendix,(Indsæt reference til apendix her!!!!!) and added to the functiontable. Also every user defined function or actions will be added to this functiontable. 

\subsection{FuncSymbol \& FuncSymbolTable}
To keep track of the varies functions and their parameters, return values and Robocode names, a FuncSymbol class is used as representation for a single function and a FuncSymbolTable class is used to keep track of every FuncSymbol in the program.
The FuncSymbol has a string members for Name, Type, ReturnType, original Robocode names and a string array for the parameters.

The FuncSymbolTable is basically a key/value pair HashMap. Where the key is the type of the function followed by the name of the function. The type in this case, can be either Function or Action from userdefined functions, Tank, Gun, Battlefield, Radar or Utils from Robocode functions or the name of the event from Robocode events.
This class has two functions, GetFuncSymbol and EnterFuncSymbol which can be found in listing \ref{cs}. 

The GetFuncSymbol takes a type and a name from a function, combines them, looks for them in the HashMap and returns the result.

EnterFuncSymbol takes a FuncSymbol and tries to add it to the HashMap. First it checks if a function with same type and name was already declared, if such a function exists, an error is thrown, otherwise the function is added to the HashMap.

\begin{lstlisting}[caption="FuncSymbolTable", label="FST"]
public class FuncSymbolTable {

	public LinkedHashMap<String, FuncSymbol> Map = new LinkedHashMap<String, FuncSymbol>();

	public FuncSymbol GetFuncSymbol(String type, String name){
    	FuncSymbol sym = Map.get(type + name);
    	return sym;
	}

	public void EnterFuncSymbol(FuncSymbol fs){
    	FuncSymbol oldSym = GetFuncSymbol(fs.Type, fs.Name);
    	if (oldSym != null) {
        	Error e = new Error("Function already declared");
        	throw e;
    	}
    	Map.put(fs.Type + fs.Name, fs);
	}
}
\end{lstlisting}

Forklar måden hvor på vi mapper robocode funktioner til vores funktioner
Forklar om den listener og walker vi bruger og hvordan de virker. (I hvert fald  få forklaret hvodan vi implementere dem her, hvis de er beskrevet  i den section før)
Error handling
Forklar om de to forskellige functables der bliver generete af henholdsvis bruger og fra den fil der bilver loadet ind. 

\subsection{Robocode functions \& events}
To allow the typechecker and codegeneration phase to do their jobs, every Robocode function and event needs to be added to the FuncSymbolTable. To do this a simple textfile was created which line for line have each function written out in a specific manner. 

WE COULD EXPLAIN THE TEXTFILE AND THE ALGORITHM USED TO LOAD IT IN IF WE HAVE TIME!!

\subsection{Userdefined Functions \& Actions}
To load the user defined functions from the program, a traverse of the parse tree is done using the Antlr generated walker/listener. For every Function and Action the listener visits, a new FuncSymbol is created and added to the FuncSymbolTable. This is done with the FuncListener class, which extends the BaseListener Antlr created.
 
The FuncListener class overrides the Enter/Exit Action declaration functions, the Enter/Exit Function declaration functions and the Enter parameter function. In the Enter Action and Function declaration functions, a new FuncSymbol is created called CurrentFunc. To CurrentFunc a name and a type is added, and in the Function case a return type is added aswell. Name, type and return type are found using the parse tree.
In the Enter parameter function adds a new parameter to the CurrentFunc's array of parameters. 
Now in the Exit Action and Function declaration functions the CurrentFunc gets added to the FuncSymbolTable. 
The reason the CurrentFunc is added in the Exit functions, is that the walker have to visit all the parameters. 

\section{Type checking}
Forklar vi "overskriver" visitoren, eller vi bruger visitoren. 


\section{Code generation}


\section{Compiling}


TO DO
Rename Txt og TEXT til String.
Open og close scope i functionBlockContext
CodeGen errors
Ændre while i codegen
Lav billede til Environment store model, og forklar det!
Apendix, skriv tekst til det vi har, overvej om der skal tilføjes kode eksempler.
Formuler en problem stilling i introduction.



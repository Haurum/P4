\chapter{Language Description}
\label{chap:LanguageDescription}
In this chapter we will overview some features of our language by means of a simple example. Then we will provide formal description of its syntax. 

\section{Syntax walkthrough}
In this section an example of a sample robot from Robocode has been introduced and can be found in listing \ref{lst:corners}.

\begin{lstlisting}[caption={Eksampel of the sample robot "Corners" in our language}, label={lst:corners}]
Tankname corners;
Num others;
Num corner = 0;
Bool stopWhenSeeRobot = False;

Setup{
  others = Battlefield.enemies();  
  run goCorner();	 
  Num gunIncrement = 3;
}

Repeat{  
  Num i = 0;
  
  repeat while(i < 30){
    Gun.turn(gunIncrement * -1);
    i = i+1;
  }  
  gunIncrement = gunIncrement * -1;
}

Action goCorner(){
  stopWhenSeeRobot = false;  
  Tank.turn(Math.normalRelativeAngleDegrees(corner - Tank.heading()));      
  stopWhenSeeRobot = true;
  Tank.forward(5000);
  Tank.turn(-90);
  Tank.forward(5000);
  Gun.turn(-90);
}

When scannedRobot{
  if(stopWhenSeeRobot){
    Tank.stop();                                     
    run smartFire(Event.distance());
    Radar.scan();                                     
    Tank.resume();                                   
  }else{
    run smartFire(Event.distance());
  }
}

Action smartFire(Num robotDistance){
  if(robotDistance > 200 OR Tank.energy() < 15){
    Gun.fire(1);
  } else if (robotDistance > 50) {
    Gun.fire(2);
  } else {
    Gun.fire(3);
  }
}

When death{
  if(others IS= 0){
    return;
  }
  
  if((others - getOthers()) / others < 0.75){
    corner = corner + 90;
    if(corner IS= 270) {
      corner = -90;
    }
    print("I died and did poorly... switching corner to " + corner);
  } else {
    print("I died but did well.  I will still use corner " + corner);
  }
}
\end{lstlisting}

Robocodes sample robot, Corners \cite{Corners}, will as find a specific corner where to stay for the entire round, and shoot at other robots whenever scanned. Initially Corners goes to the top left corner. When Corners dies, it will see if it did well or poorly it will either use the same corner or move clockwise to the next corner on the battlefield.

In line 1-5 the Tankname is set and some global variables, are declared and initialized. The Setup block in listing \ref{lst:setup} is a block there run once at the beginning of each round. In this example the Setup block is used to store in the global variable "other" the initial number of enemies. This value is obtained by calling the build-in function Battlefield.enemies(). It will run the action goCorner, which will be explained later. As the last thing, the Setup block declares a variable, gunIncrement, of type num and initializes its value to 3.

\begin{lstlisting}[caption={Code listing of the Setup block},  xleftmargin=.2\textwidth, label={lst:setup}]
Setup{
  others = Battlefield.enemies();  
  run goCorner();	 
  Num gunIncrement = 3;
}
\end{lstlisting}

To make the robot do repetitive actions during the battles, Robot, Gun and Radar behaviour can be placed in the Repeat block. The Repeat block is basically a loop, that will iterate through the robot's Robot, Gun and Radar behaviour. The Repeat block of the sample robot Corners, in listing \ref{lst:Repeat}, consists of a repeat while loop. At the end of the repeat while loop, the gun have been turned a total of 90 or -90 degrees. 

\begin{lstlisting}[caption={Code listing of the Repeat block}, xleftmargin=.2\textwidth, label={lst:Repeat}]
Repeat{  
  Num i = 0;
  
  repeat while(i < 30){
    Gun.turn(gunIncrement * -1);
    i = i+1;
  }  
  gunIncrement = gunIncrement * -1;
}
\end{lstlisting}

In our language an Action is compared to the langauge C, a procedure in C. Corners uses an Action goCorner(), to move to the desired corner. In the first round of the battle, it will turn the robot the amount of degrees so it is facing the top wall, which is done at line 3 in listing \ref{lst:goCorner}. The degrees are calculated by subtracting the corner variable from the robots heading. "Heading" is getting the robot's heading, which is the direction the robot is facing. It will then move forward until it hits the wall, turn -90 degrees, again  move forward until it hits the wall and turn the gun -90 degrees. At the end of the execution of this action, the robot should be sitting in a corner, ready to turn its gun 90 degrees clockwise or counter-clockwise.


\begin{lstlisting}[caption={Code listing of the Action goCorner()}, xleftmargin=.2\textwidth, label={lst:goCorner}]
Action goCorner(){
  stopWhenSeeRobot = false;  
  Tank.turn(Math.normalRelativeAngleDegrees(corner - Tank.heading()));      
  stopWhenSeeRobot = true;
  Tank.forward(5000);
  Tank.turn(-90);
  Tank.forward(5000);
  Gun.turn(-90);
}
\end{lstlisting}

One of the most peculiar things about Robocode is the use of events. The event handlers are indicated by the reserved word "When". 
In the Action goCorner(), a variable of type bool is set to false on line 2 and set to true in line 4 in listing \ref{lst:goCorner}. This variable is used in the event scannedRobot() found in listing \ref{lst:scannedRobot}. If the before mentioned bool is true, a build-in function Tank.Stop() is used to stop the robots movement, then it uses the action "smartfire", where the power of the shoot will be determined by the distance between the robot and the scannedRobot. The robot will then use Radar.scan() and resume it's movement towards the corner. If the bool was false, the robot is already in the corner, and will shoot at scanned robots.

If an event listener is listening to the event, it can detect when the event is triggered and make sure the event handler is executed. When the behaviour in the event has been run, the robot will continue running the Repeat block.  


\begin{lstlisting}[caption={Code listing of the event scannedRobot()} label=corners3, xleftmargin=.2\textwidth, label={lst:scannedRobot}]
When scannedRobot{
  if(stopWhenSeeRobot){
    Tank.stop();                                     
    run smartFire(Event.distance());
    Radar.scan();                                     
    Tank.resume();                                   
  }else{
    run smartFire(Event.distance());
  }
}
\end{lstlisting}

Consider if the event Death should be explanied here for the example Corners. 


\section{Grammar}
\label{sec:Grammar}
In this section we present the syntax of the language. The syntax is formally presented by means of a context-free grammar in extended BNF.

\begin{lstlisting}[label={lst:CFG}]
grammar Grammar;

prog : dcls EOF;
tankname : 'Tankname' ID ';';
setupblock : 'Setup' block;
repeatblock : 'Repeat' block;

dcls : (actdcl
     | funcdcl
     | vardcl';'
     | setupblock
     | repeatblock
     | tankname
     | eventdcl
     | print';')*
     ;

actdcl : 'Action' ID '(' params? ')'block;
funcdcl : 'Function' ID '(' params? ')' 'returns' TYPE functionBlock;
functionBlock : '{' stmts returnstmt';' '}';
params : param (',' param)*;
param : TYPE ID;
eventdcl : 'When' ID block;
block : '{' stmts '}';

stmts : (assign';'
      |vardcl';'
      |ifstmt
      |whilestmt
      |call';'
      |print';')*
      ;

assign : ID '=' expr;
vardcl : TYPE (ID|assign);
ifstmt : 'if''('expr')' block elseif* ('else' block)?;
elseif : 'else''if''('expr')' block;
whilestmt : 'repeat' ('while''('expr')' block
          | block 'while''('expr')')
          ;

returnstmt : 'return' expr?;
print : 'print('expr')';

call : acall
     | fcall
     | rcall
     | ecall
     ;

acall : 'run' ID'('args?')';
fcall : ID'('args?')';

rcall   : 'Tank.'ID'('args?')'
        | 'Gun.'ID'('args?')'
        | 'Radar.'ID'('args?')'
        | 'Battlefield.'ID'('args?')'
        | 'Math.'ID'('args?')'
        ;

ecall : 'Event.'ID'('args?')';
args : expr (',' expr)*;

expr    : MINUS expr                           #unexpr
        | NOT expr                             #notexpr
        | expr op=(MULT | DIV | MOD) expr      #mulexpr
        | expr op=(PLUS | MINUS) expr          #addexpr
        | expr op=(LTEQ | GTEQ | LT | GT) expr #relexpr
        | expr op=(EQ | NEQ) expr              #eqexpr
        | expr AND expr                        #andexpr
        | expr OR expr                         #orexpr
        | atomic                               #atomicexpr
        ;

atomic : '(' expr ')'
     | call
     | literal
     ;

literal : ID        #id
        | NUM       #num
        | STRING    #string
        | BOOL      #bool
        ;

COMMENT : '/*'~['*/']*'*/' -> skip;
SPACE : [ \r\t\n] -> skip;

\end{lstlisting}


\subsection{Lexicon}
The definition of what input are allowed for each lexical in the grammar is defined by regular expressions. This will be described here with a table of terminals with matching regex, found in table \ref{fig:Lexicon}. A stream of characters is read by the scanner of the compiler and then turned into a lexical defined by the regex.
Due to the way the context-free grammar is implemented there are not a lot of terminals. This is because that the terminal \emph{ID} is used widely through the CFG. The general usage of this term creates consistency for the user giving that they quickly can get a feel for what input is allowed. 

\begin{table}[]
\centering
\begin{tabular}{|l|l|}
\hline
Terminal & Regular expressions                \\ \hline
ID       & {[}a-z{]} ({[}a-z{]} | {[}A-Z{]})* \\ \hline
OR		 & 'OR'								  \\ \hline
AND		 & 'AND'							  \\ \hline
EQ		 & 'IS=' | 'NOT='					  \\ \hline
REL		 & '>'|'<'|'>='|'<='					  \\ \hline
ADD		 & '+'|'-'							  \\ \hline
MUL		 & '*'|'/'							  \\ \hline
NUM		 & [0-9]+("."[0-9]*)?|"."[0-9]+\\ \hline
BOOL 	 & 'false' | 'true'					  \\ \hline
STRING 	 & '"'.*'"'						      \\ \hline
TYPE     & 'Num' | 'Bool' | 'Text'            \\ \hline


\end{tabular}
\caption{Table with terminals and matching regular expressions.}
\label{fig:Lexicon}
\end{table}

\section{Type systems}

\subsection{Type rules}
The following subsection will describe the type rules of the language. These rules will express which operators can be applied to each type, and how each expression will have a type, determined by the operands and operators in the expression.
Operators has been divided into groups, and each group of operators has semantically equivalent rules.
The operators [+, -, *, /, \%] will be used as the shorthand 'op'. Relational operators [<, >, <=, >=, NOT=, IS=, AND, OR] will be used as the shorthand 'relop'. There's two different types of negations, one for numbers and one for bools: -(num) for numbers, and NOT(bool) for bools.
\[
\dfrac{\Gamma \vdash e_1 : num \Gamma \vdash e_2 : num}{\Gamma \vdash e_1 op e_2 : num}
\]
\[
\dfrac{\Gamma \vdash e_1 : num \Gamma \vdash e_2 : num}{\Gamma \vdash e_1 relop e_2 : bool}
\]
\[
\dfrac{\Gamma \vdash e_1 : num}{\Gamma \vdash -e_1 : num}
\]
\[
\dfrac{\Gamma \vdash e_1 : string \Gamma \vdash e_2 : \tau}{\Gamma \vdash e_1 + e_2 : string}
\]
\[
\dfrac{\Gamma \vdash e_1 : bool \Gamma \vdash e_2 : bool}{\Gamma \vdash e_1 relop e_2 : bool}
\]
\[
\dfrac{\Gamma \vdash e_1 : bool}{\Gamma \vdash NOTe_1 : bool}
\]
\subsection{Scope rules}
Lav indledning fra Sebesta s. 218 om, forklar og beskriv de scopes vi har. 

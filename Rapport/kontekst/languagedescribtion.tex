\chapter{Language Description}
\label{chap:LanguageDescription}
In this chapter we will overview some features of our language by means of a simple example. Then we will provide formal description of its syntax. 

\section{Syntax walkthrough}
In this section an example of a sample robot from Robocode has been introduced and can be found in listing \ref{lst:corners}.

\begin{lstlisting}[caption={Eksampel of the sample robot "Corners" in our language}, label={lst:corners}]
Tankname corners;
Num others;
Num corner = 0;
Bool stopWhenSeeRobot = False;

Setup{
  others = Battlefield.enemies();  
  run goCorner();	 
  Num gunIncrement = 3;
}

Repeat{  
  Num i = 0;
  
  repeat while(i < 30){
    Gun.turn(gunIncrement * -1);
    i = i+1;
  }  
  gunIncrement = gunIncrement * -1;
}

Action goCorner(){
  stopWhenSeeRobot = false;  
  Tank.turn(Math.normalRelativeAngleDegrees(corner - Tank.heading()));      
  stopWhenSeeRobot = true;
  Tank.forward(5000);
  Tank.turn(-90);
  Tank.forward(5000);
  Gun.turn(-90);
}

When scannedRobot{
  if(stopWhenSeeRobot){
    Tank.stop();                                     
    run smartFire(Event.distance());
    Radar.scan();                                     
    Tank.resume();                                   
  }else{
    run smartFire(Event.distance());
  }
}

Action smartFire(Num robotDistance){
  if(robotDistance > 200 OR Tank.energy() < 15){
    Gun.fire(1);
  } else if (robotDistance > 50) {
    Gun.fire(2);
  } else {
    Gun.fire(3);
  }
}

When death{
  if(others IS= 0){
    return;
  }
  
  if((others - getOthers()) / others < 0.75){
    corner = corner + 90;
    if(corner IS= 270) {
      corner = -90;
    }
    print("I died and did poorly... switching corner to " + corner);
  } else {
    print("I died but did well.  I will still use corner " + corner);
  }
}
\end{lstlisting}

Robocodes sample robot, Corners \cite{Corners}, will as find a specific corner where to stay for the entire round, and shoot at other robots whenever scanned. Initially Corners goes to the top left corner. When Corners dies, it will see if it did well or poorly it will either use the same corner or move clockwise to the next corner on the battlefield.

In line 1-5 the Tankname is set and some global variables, are declared and initialized. The Setup block in listing \ref{lst:setup} is a block there run once at the beginning of each round. In this example the Setup block is used to store in the global variable "other" the initial number of enemies. This value is obtained by calling the build-in function Battlefield.enemies(). It will run the action goCorner, which will be explained later. As the last thing, the Setup block declares a variable, gunIncrement, of type num and initializes its value to 3.

\begin{lstlisting}[caption={Code listing of the Setup block},  xleftmargin=.2\textwidth, label={lst:setup}]
Setup{
  others = Battlefield.enemies();  
  run goCorner();	 
  Num gunIncrement = 3;
}
\end{lstlisting}

To make the robot do repetitive actions during the battles, Robot, Gun and Radar behaviour can be placed in the Repeat block. The Repeat block is basically a loop, that will iterate through the robot's Robot, Gun and Radar behaviour. The Repeat block of the sample robot Corners, in listing \ref{lst:Repeat}, consists of a repeat while loop. At the end of the repeat while loop, the gun have been turned a total of 90 or -90 degrees. 

\begin{lstlisting}[caption={Code listing of the Repeat block}, xleftmargin=.2\textwidth, label={lst:Repeat}]
Repeat{  
  Num i = 0;
  
  repeat while(i < 30){
    Gun.turn(gunIncrement * -1);
    i = i+1;
  }  
  gunIncrement = gunIncrement * -1;
}
\end{lstlisting}

In our language an Action is compared to the langauge C, a procedure in C. Corners uses an Action goCorner(), to move to the desired corner. In the first round of the battle, it will turn the robot the amount of degrees so it is facing the top wall, which is done at line 3 in listing \ref{lst:goCorner}. The degrees are calculated by subtracting the corner variable from the robots heading. "Heading" is getting the robot's heading, which is the direction the robot is facing. It will then move forward until it hits the wall, turn -90 degrees, again  move forward until it hits the wall and turn the gun -90 degrees. At the end of the execution of this action, the robot should be sitting in a corner, ready to turn its gun 90 degrees clockwise or counter-clockwise.


\begin{lstlisting}[caption={Code listing of the Action goCorner()}, xleftmargin=.2\textwidth, label={lst:goCorner}]
Action goCorner(){
  stopWhenSeeRobot = false;  
  Tank.turn(Math.normalRelativeAngleDegrees(corner - Tank.heading()));      
  stopWhenSeeRobot = true;
  Tank.forward(5000);
  Tank.turn(-90);
  Tank.forward(5000);
  Gun.turn(-90);
}
\end{lstlisting}

One of the most peculiar things about Robocode is the use of events. The event handlers are indicated by the reserved word "When". 
In the Action goCorner(), a variable of type bool is set to false on line 2 and set to true in line 4 in listing \ref{lst:goCorner}. This variable is used in the event scannedRobot() found in listing \ref{lst:scannedRobot}. If the before mentioned bool is true, a build-in function Tank.Stop() is used to stop the robots movement, then it uses the action "smartfire", where the power of the shoot will be determined by the distance between the robot and the scannedRobot. The robot will then use Radar.scan() and resume it's movement towards the corner. If the bool was false, the robot is already in the corner, and will shoot at scanned robots.

If an event listener is listening to the event, it can detect when the event is triggered and make sure the event handler is executed. When the behaviour in the event has been run, the robot will continue running the Repeat block.  


\begin{lstlisting}[caption={Code listing of the event scannedRobot()} label=corners3, xleftmargin=.2\textwidth, label={lst:scannedRobot}]
When scannedRobot{
  if(stopWhenSeeRobot){
    Tank.stop();                                     
    run smartFire(Event.distance());
    Radar.scan();                                     
    Tank.resume();                                   
  }else{
    run smartFire(Event.distance());
  }
}
\end{lstlisting}

Consider if the event Death should be explanied here for the example Corners. 


\section{Grammar}
\label{sec:Grammar}
In this section we present the syntax of the language. The syntax is formally presented by means of a context-free grammar in extended BNF.

\begin{lstlisting}[label={lst:CFG}]
grammar Grammar;

prog : dcls EOF;
tankname : 'Tankname' ID ';';
setupblock : 'Setup' block;
repeatblock : 'Repeat' block;

dcls : (actdcl
     | funcdcl
     | vardcl';'
     | setupblock
     | repeatblock
     | tankname
     | eventdcl
     | print';')*
     ;

actdcl : 'Action' ID '(' params? ')'block;
funcdcl : 'Function' ID '(' params? ')' 'returns' TYPE functionBlock;
functionBlock : '{' stmts returnstmt';' '}';
params : param (',' param)*;
param : TYPE ID;
eventdcl : 'When' ID block;
block : '{' stmts '}';

stmts : (assign';'
      |vardcl';'
      |ifstmt
      |whilestmt
      |call';'
      |print';')*
      ;

assign : ID '=' expr;
vardcl : TYPE (ID|assign);
ifstmt : 'if''('expr')' block elseif* ('else' block)?;
elseif : 'else''if''('expr')' block;
whilestmt : 'repeat' ('while''('expr')' block
          | block 'while''('expr')')
          ;

returnstmt : 'return' expr?;
print : 'print('expr')';

call : acall
     | fcall
     | rcall
     | ecall
     ;

acall : 'run' ID'('args?')';
fcall : ID'('args?')';

rcall   : 'Tank.'ID'('args?')'
        | 'Gun.'ID'('args?')'
        | 'Radar.'ID'('args?')'
        | 'Battlefield.'ID'('args?')'
        | 'Math.'ID'('args?')'
        ;

ecall : 'Event.'ID'('args?')';
args : expr (',' expr)*;

expr    : MINUS expr                           #unexpr
        | NOT expr                             #notexpr
        | expr op=(MULT | DIV | MOD) expr      #mulexpr
        | expr op=(PLUS | MINUS) expr          #addexpr
        | expr op=(LTEQ | GTEQ | LT | GT) expr #relexpr
        | expr op=(EQ | NEQ) expr              #eqexpr
        | expr AND expr                        #andexpr
        | expr OR expr                         #orexpr
        | atomic                               #atomicexpr
        ;

atomic : '(' expr ')'
     | call
     | literal
     ;

literal : ID        #id
        | NUM       #num
        | STRING    #string
        | BOOL      #bool
        ;

COMMENT : '/*'~['*/']*'*/' -> skip;
SPACE : [ \r\t\n] -> skip;

\end{lstlisting}


\subsection{Lexicon}
The definition of what input are allowed for each lexical in the grammar is defined by regular expressions. This will be described here with a table of terminals with matching regex, found in table \ref{fig:Lexicon}. A stream of characters is read by the scanner of the compiler and then turned into a lexical defined by the regex.
Due to the way the context-free grammar is implemented there are not a lot of terminals. This is because that the terminal \emph{ID} is used widely through the CFG. The general usage of this term creates consistency for the user giving that they quickly can get a feel for what input is allowed. 

\begin{table}[]
\centering
\begin{tabular}{|l|l|}
\hline
Terminal & Regular expressions                \\ \hline
ID       & {[}a-z{]} ({[}a-z{]} | {[}A-Z{]})* \\ \hline
OR		 & 'OR'								  \\ \hline
AND		 & 'AND'							  \\ \hline
EQ		 & 'IS=' | 'NOT='					  \\ \hline
REL		 & '>'|'<'|'>='|'<='					  \\ \hline
ADD		 & '+'|'-'							  \\ \hline
MUL		 & '*'|'/'							  \\ \hline
NUM		 & [0-9]+("."[0-9]*)?|"."[0-9]+\\ \hline
BOOL 	 & 'false' | 'true'					  \\ \hline
STRING 	 & '"'.*'"'						      \\ \hline
TYPE     & 'Num' | 'Bool' | 'Text'            \\ \hline


\end{tabular}
\caption{Table with terminals and matching regular expressions.}
\label{fig:Lexicon}
\end{table}

\section{Language constructs}
Lav definitioner til hver contruct:
Forklaring hvonår det er den contructs og hvad den gør(Så som hvad den tager som input og giver som output)

Til hver definition, lav en tekst om hvad den bruges til og hvorfor den er med i vores sprog.

\subsection{Setup block}
The Setup block is a block run only once at the begining of each round. In this block the user can define colors of different parts of the robot, call user defined functions which should only be called in once in the beginning and reserved calls. 

\begin{defi}
The Setup block consists of the reserved word Setup followed by \{ \textbf{body} \}, where the body is the userdefined code. 
\end{defi}

\subsection{Repeat block}
The Repeat block will iterate through the users code, unless an event has occurred which then have first priority. The Repeat block is the general behaviour and logic of the robot, and will often contain the main movements of the robot.

\begin{defi}
The Repeat block is defined with the reserved word Repeat followed by \{ \textbf{body} \}, where the body is the userdefined code.
\end{defi}
\subsection{When block}


\begin{defi}
Hello?
\end{defi}
\subsection{Variables}


\begin{defi}
Hello?
\end{defi}
\subsection{Actions}


\begin{defi}
Hello?
\end{defi}
\subsection{Functions}


\begin{defi}
Hello?
\end{defi}
\subsection{Reserved calls}


\begin{defi}
Hello?
\end{defi}
\subsection{Conditional block}


\begin{defi}
Hello?
\end{defi}
\subsection{Expressions}


\begin{defi}
Hello?
\end{defi}
\section{Type systems}
Missing intro!

\subsection{Type rules}
The following subsection will describe the type rules of the language. These rules will express which operators can be applied to each type, and how each expression will have a type, determined by the operands and operators in the expression.
Operators has been divided into groups, and each group of operators has semantically equivalent rules.
The operators [+, -, *, /, \%] will be used as the shorthand 'op'. Relational operators [<, >, <=, >=, NOT=, IS=, AND, OR] will be used as the shorthand 'relop'. There's two different types of negations, one for numbers and one for bools: -(num) for numbers, and NOT(bool) for bools.
\[
\dfrac{\Gamma \vdash e_1 : num \Gamma \vdash e_2 : num}{\Gamma \vdash e_1 op e_2 : num}
\]
\[
\dfrac{\Gamma \vdash e_1 : num \Gamma \vdash e_2 : num}{\Gamma \vdash e_1 relop e_2 : bool}
\]
\[
\dfrac{\Gamma \vdash e_1 : num}{\Gamma \vdash -e_1 : num}
\]
\[
\dfrac{\Gamma \vdash e_1 : string \Gamma \vdash e_2 : \tau}{\Gamma \vdash e_1 + e_2 : string}
\]
\[
\dfrac{\Gamma \vdash e_1 : bool \Gamma \vdash e_2 : bool}{\Gamma \vdash e_1 relop e_2 : bool}
\]
\[
\dfrac{\Gamma \vdash e_1 : bool}{\Gamma \vdash NOTe_1 : bool}
\]
\subsection{Scope rules}
Lav indledning fra Sebesta s. 218 om, forklar og beskriv de scopes vi har. 

Scope rules are where the users variables are visible. In our language there is three kind of scopes: local scope, global scope and function scope. A variable is visible in the specific scope, if can be referenced to. Two variables of the same name, can't be in the same scope. The local variables are declared inside blocks of code, where the blocks are marked with \{ \}. In the example in listing \ref{lst:example} the variable degrees is declared locally in the code block Setup, and it can't be used in other code blocks unless it is nested inside of the Setup block, it could e.g. be used in a if-loop in the Setup block. 

\begin{lstlisting}[caption={Example of local scoping rules},  xleftmargin=.2\textwidth, label={lst:example}]
Setup{
	num degrees;
	degrees = 90;
	
	Tank.forward(degrees);
}
\end{lstlisting}

The parameters declared in a function, is visible in the function scope and can be used just as local variables for the function. The parameters can't be masked by declaring new local variables in the function, since the value of the parameters can't be stored. The parameters can't be named the same as the local- and global variables. 

When a variable is declared in the global scope, it can be used in all of the other functions and code blocks. When a variable is used, it will first search for it in the local scope, if it is not found in the local scope, it will search the in the global scope. In listing \ref{lst:example1} Codeblock1 uses the global variable, where Codeblock2 uses a local variable with the same name as the global variable, but the local variable will be used.

\begin{lstlisting}[caption={Example of global scoping rules},  xleftmargin=.2\textwidth, label={lst:example1}]
Num number = 2; /* Declared globally */

Codeblock1{
	5 + number; /* Will use the global variable number */
}

Codeblock2{
	Num number = 5; /* Locally declared variable */
	5 + number; /* Will use the global variable number */
}
\end{lstlisting}

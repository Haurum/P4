\chapter{Language Description}
\label{chap:LanguageDescription}
In this chapter we will overview some features of our language by means of a simple example. Then we will provide formal description of its syntax. 

\section{Syntax walkthrough}
In this section an example of a sample robot from Robocode has been introduced and can be found in listing \ref{lst:corners}.

\begin{lstlisting}[caption={Eksampel of the sample robot "Corners" in our language}, label={lst:corners}]
Tankname corners;
Num others;
Num corner = 0;
Bool stopWhenSeeRobot = False;

Setup{
  others = Battlefield.enemies();  
  run goCorner();	 
  Num gunIncrement = 3;
}

Repeat{  
  Num i = 0;
  
  repeat while(i < 30){
    Gun.turn(gunIncrement * -1);
    i = i+1;
  }  
  gunIncrement = gunIncrement * -1;
}

Action goCorner(){
  stopWhenSeeRobot = false;  
  Tank.turn(Math.normalRelativeAngleDegrees(corner - Tank.heading()));      
  stopWhenSeeRobot = true;
  Tank.forward(5000);
  Tank.turn(-90);
  Tank.forward(5000);
  Gun.turn(-90);
}

When scannedRobot{
  if(stopWhenSeeRobot){
    Tank.stop();                                     
    run smartFire(Event.distance());
    Radar.scan();                                     
    Tank.resume();                                   
  }else{
    run smartFire(Event.distance());
  }
}

Action smartFire(Num robotDistance){
  if(robotDistance > 200 OR Tank.energy() < 15){
    Gun.fire(1);
  } else if (robotDistance > 50) {
    Gun.fire(2);
  } else {
    Gun.fire(3);
  }
}

When death{
  if(others IS= 0){
    return;
  }
  
  if((others - getOthers()) / others < 0.75){
    corner = corner + 90;
    if(corner IS= 270) {
      corner = -90;
    }
    print("I died and did poorly... switching corner to " + corner);
  } else {
    print("I died but did well.  I will still use corner " + corner);
  }
}
\end{lstlisting}

Robocodes sample robot, Corners \cite{Corners}, will as find a specific corner where to stay for the entire round, and shoot at other robots whenever scanned. Initially Corners goes to the top left corner. When Corners dies, it will see if it did well or poorly it will either use the same corner or move clockwise to the next corner on the battlefield.

In line 1-5 the Tankname is set and some global variables, are declared and initialized. The Setup block in listing \ref{lst:setup} is a block there run once at the beginning of each round. In this example the Setup block is used to store in the global variable "other" the initial number of enemies. This value is obtained by calling the build-in function Battlefield.enemies(). It will run the action goCorner, which will be explained later. As the last thing, the Setup block declares a variable, gunIncrement, of type num and initializes its value to 3.

\begin{lstlisting}[caption={Code listing of the Setup block},  xleftmargin=.2\textwidth, label={lst:setup}]
Setup{
  others = Battlefield.enemies();  
  run goCorner();	 
  Num gunIncrement = 3;
}
\end{lstlisting}

To make the robot do repetitive actions during the battles, Robot, Gun and Radar behaviour can be placed in the Repeat block. The Repeat block is basically a loop, that will iterate through the robot's Robot, Gun and Radar behaviour. The Repeat block of the sample robot Corners, in listing \ref{lst:Repeat}, consists of a repeat while loop. At the end of the repeat while loop, the gun have been turned a total of 90 or -90 degrees. 

\begin{lstlisting}[caption={Code listing of the Repeat block}, xleftmargin=.2\textwidth, label={lst:Repeat}]
Repeat{  
  Num i = 0;
  
  repeat while(i < 30){
    Gun.turn(gunIncrement * -1);
    i = i+1;
  }  
  gunIncrement = gunIncrement * -1;
}
\end{lstlisting}

In our language an Action is compared to the langauge C, a procedure in C. Corners uses an Action goCorner(), to move to the desired corner. In the first round of the battle, it will turn the robot the amount of degrees so it is facing the top wall, which is done at line 3 in listing \ref{lst:goCorner}. The degrees are calculated by subtracting the corner variable from the robots heading. "Heading" is getting the robot's heading, which is the direction the robot is facing. It will then move forward until it hits the wall, turn -90 degrees, again  move forward until it hits the wall and turn the gun -90 degrees. At the end of the execution of this action, the robot should be sitting in a corner, ready to turn its gun 90 degrees clockwise or counter-clockwise.


\begin{lstlisting}[caption={Code listing of the Action goCorner()}, xleftmargin=.2\textwidth, label={lst:goCorner}]
Action goCorner(){
  stopWhenSeeRobot = false;  
  Tank.turn(Math.normalRelativeAngleDegrees(corner - Tank.heading()));      
  stopWhenSeeRobot = true;
  Tank.forward(5000);
  Tank.turn(-90);
  Tank.forward(5000);
  Gun.turn(-90);
}
\end{lstlisting}

One of the most peculiar things about Robocode is the use of events. The event handlers are indicated by the reserved word "When". 
In the Action goCorner(), a variable of type bool is set to false on line 2 and set to true in line 4 in listing \ref{lst:goCorner}. This variable is used in the event scannedRobot() found in listing \ref{lst:scannedRobot}. If the before mentioned bool is true, a build-in function Tank.Stop() is used to stop the robots movement, then it uses the action "smartfire", where the power of the shoot will be determined by the distance between the robot and the scannedRobot. The robot will then use Radar.scan() and resume it's movement towards the corner. If the bool was false, the robot is already in the corner, and will shoot at scanned robots.

If an event listener is listening to the event, it can detect when the event is triggered and make sure the event handler is executed. When the behaviour in the event has been run, the robot will continue running the Repeat block.  


\begin{lstlisting}[caption={Code listing of the event scannedRobot()} label=corners3, xleftmargin=.2\textwidth, label={lst:scannedRobot}]
When scannedRobot{
  if(stopWhenSeeRobot){
    Tank.stop();                                     
    run smartFire(Event.distance());
    Radar.scan();                                     
    Tank.resume();                                   
  }else{
    run smartFire(Event.distance());
  }
}
\end{lstlisting}

Consider if the event Death should be explanied here for the example Corners. 


\section{Grammar}
\label{sec:Grammar}
In this section we present the syntax of the language. The syntax is formally presented by means of a context-free grammar in extended BNF.

\begin{lstlisting}[label={lst:CFG}]
grammar Grammar;

prog : dcls EOF;
tankname : 'Tankname' ID ';';
setupblock : 'Setup' block;
repeatblock : 'Repeat' block;

dcls : (actdcl
     | funcdcl
     | vardcl';'
     | setupblock
     | repeatblock
     | tankname
     | eventdcl
     | print';')*
     ;

actdcl : 'Action' ID '(' params? ')'block;
funcdcl : 'Function' ID '(' params? ')' 'returns' TYPE functionBlock;
functionBlock : '{' stmts returnstmt';' '}';
params : param (',' param)*;
param : TYPE ID;
eventdcl : 'When' ID block;
block : '{' stmts '}';

stmts : (assign';'
      |vardcl';'
      |ifstmt
      |whilestmt
      |call';'
      |print';')*
      ;

assign : ID '=' expr;
vardcl : TYPE (ID|assign);
ifstmt : 'if''('expr')' block elseif* ('else' block)?;
elseif : 'else''if''('expr')' block;
whilestmt : 'repeat' ('while''('expr')' block | block 'while''('expr')');

returnstmt : 'return' expr;
print : 'print('expr')';

call : acall
     | fcall
     | rcall
     | ecall
     ;

acall : 'run' ID'('args?')';
fcall : ID'('args?')';

rcall   : 'Tank.'ID'('args?')'
        | 'Gun.'ID'('args?')'
        | 'Radar.'ID'('args?')'
        | 'Battlefield.'ID'('args?')'
        | 'Math.'ID'('args?')'
        ;

ecall : 'Event.'ID'('args?')';
args : expr (',' expr)*;

expr    : MINUS expr                           #unexpr
        | NOT expr                             #notexpr
        | expr op=(MULT | DIV | MOD) expr      #mulexpr
        | expr op=(PLUS | MINUS) expr          #addexpr
        | expr op=(LTEQ | GTEQ | LT | GT) expr #relexpr
        | expr op=(EQ | NEQ) expr              #eqexpr
        | expr AND expr                        #andexpr
        | expr OR expr                         #orexpr
        | atomic                               #atomicexpr
        ;

atomic : '(' expr ')'
     | call
     | literal
     ;

literal : ID        #id
        | NUM       #num
        | STRING    #string
        | BOOL      #bool
        ;

COMMENT : '/*'~['*/']*'*/' -> skip;
SPACE : [ \r\t\n] -> skip;

\end{lstlisting}


\subsection{Lexicon}
The definition of what input are allowed for each lexeme in the grammar is defined by means of regular expressions. This will be described here with a table of terminals with matching regex, found in table \ref{fig:Lexicon}. A stream of characters is read by the scanner of the compiler and then turned into a token name defined by the regex.
Due to the way the context-free grammar is implemented there are not a lot of terminals. This is because that the terminal \emph{ID} is used widely through the CFG. The general usage of this term creates consistency for the user giving that they quickly can get a feel for what input is allowed. 

\begin{table}[]
\centering
\begin{tabular}{|l|l|}
\hline
Token & Regular expressions                \\ \hline
ID       & {[}a-z{]} ({[}a-z{]} | {[}A-Z{]})* \\ \hline
OR		 & 'OR'								  \\ \hline
AND		 & 'AND'							  \\ \hline
EQ		 & 'IS=' | 'NOT='					  \\ \hline
REL		 & '>'|'<'|'>='|'<='					  \\ \hline
ADD		 & '+'|'-'							  \\ \hline
MUL		 & '*'|'/'							  \\ \hline
NUM		 & [0-9]+("."[0-9]*)?|"."[0-9]+\\ \hline
BOOL 	 & 'false' | 'true'					  \\ \hline
STRING 	 & '"'.*'"'						      \\ \hline
TYPE     & 'Num' | 'Bool' | 'Text'            \\ \hline


\end{tabular}
\caption{Table with terminals and matching regular expressions.}
\label{fig:Lexicon}
\end{table}

\section{Language constructs}
%Lav definitioner til hver contruct:
%Forklaring hvonår det er den contructs og hvad den gør(Så som hvad den tager som input og giver som output)

%Til hver definition, lav en tekst om hvad den bruges til og hvorfor den er med i vores sprog.
Missing Intro!

\subsection{Setup block}
The Setup block is a block run only once at the begining of each round. In this block the user can define colors of different parts of the robot, call user defined functions which should only be called in once in the beginning and reserved calls. The Setup block can only be declared once, and have to be in the code, else the user will not be able to run the code.

\begin{defi}
The Setup block consists of the reserved word \textbf{Setup} followed by \{ \textbf{body} \}, where the body is the userdefined code. 
\end{defi}

\subsection{Repeat block}
The Repeat block will iterate through the users code, unless an event has occurred which then have first priority. The Repeat block is the general behaviour and logic of the robot, and will often contain the main movements of the robot. Just as the Setup block, the Repeat block ccan also only be declared once, and have to be in the code.

\begin{defi}
The Repeat block is defined with the reserved word \textbf{Repeat} followed by \{ \textbf{body} \}, where the body is the userdefined code.
\end{defi}
\subsection{When block}
The When block is handling an event whenever it occurs during the battle. The When block is preforming the behaviour and logic when the events occur, where this will be made by the user. Only a predefined number of events can be declared, which can be found in the Apendix(INSERT REFERENCE TO THE TABLE LATER!!).

\begin{defi}
The When block is defined as: When eventName \{ \textbf{body} \}, \textbf{When} is the reserved word, the name of a Robocode event followed by the body which is the user defined code.
\end{defi}
\subsection{Variables}
In our language there are three different kind of variables, \textbf{Num}, \textbf{Bool} and \textbf{Txt}. All numeric types will be interpreted as \textbf{Num}. \textbf{Bool} can either be True or False. \textbf{Txt} is an array of characters.

\begin{defi}
The variables can be declared using the reserved words \textbf{Num}, \textbf{Bool} and \textbf{Txt} followed by the desired id of the variable. If the variable should also de initialized,  the assignment operator "=" should be used followed by the value or expression for the variable. 
\end{defi}
\subsection{Action block}
An Action block is an abstraction for statements with no return types, the Actions can be called throughout the code. The parameters in the Action block is always call by value, just as in the programming language Java, this will be the same in the Function block.

\begin{defi}
An Action block is defined with the reserved word \textbf{Action} followed by the id of the Action, a desired amount of parameters in parentheses and the body of the Action block within \{\}.
An Action block will look like: \textbf{Action} myAction (parameters) \{ \textbf{body} \}.
\end{defi}
\subsection{Function block}
The Function block is very similar to the Action block. The difference of the two blocks is that the Function block have a return type. 

\begin{defi}
The function block is defined with the reserved word \textbf{Function} followed by the id of the Function, what the Function will be returning, a desired amount of parameters in parentheses and the body of the Function block within \{\}.
An example of the Function block would be: \textbf{Function} myFunction Returns returnType (parameters) \{ \textbf{body} \}
\end{defi}
\subsection{Reserved calls}
(Wait to explain this, till when we are sure if we want to rename tank, to robot???)

\begin{defi}
Hello?
\end{defi}
\subsection{Conditional block}
The conditional block is the langauge's conditional statements which will execute the user defiend code in it's body depending on a boolean expression. Conditional blocks helps making the robots logic for it's behaviour. 

\begin{defi}
The conditional block contains a minimum of one if-construct, an optional number of else if-construct and can be ended with an optional else-construct. 

The if-construct is noted with the reserved word \textbf{if} followed by the boolean expression in parentheses and the body within \{\}: If(ture) {body}.

The else if-contruct's structure is the same as the if-construct, except that the reserved  word \textbf{else if} should be used instead of the \textbf{if}. 

The else-construct is noted by the reserved word \textbf{else} followed by the the body in \{\}.
\end{defi}
\subsection{Operators}
Describe the different operators.. ? 

\begin{defi}
Hello?
\end{defi}
\section{Type systems}
Missing intro! Skriv at sebesta er blevet brugt til denne section ??

\subsection{Type rules}
The following subsection will describe the type rules of the language. These rules will express which operators can be applied to each type, and how each expression will have a type, determined by the operands and operators in the expression.
Operators have been divided into groups, and each group of operators have semantically equivalent rules.
The operators [+, -, *, /, \%] will be used as the shorthand 'op'. Relational operators [<, >, <=, >=, NOT=, IS=, AND, OR] will be used as the shorthand 'relop'. There're two different types of negations, one for numbers and one for bools: -(num) for numbers, and NOT(bool) for bools.
\[
\dfrac{\Gamma \vdash e_1 : num \Gamma \vdash e_2 : num}{\Gamma \vdash e_1 op e_2 : num}
\]
\[
\dfrac{\Gamma \vdash e_1 : num \Gamma \vdash e_2 : num}{\Gamma \vdash e_1 relop e_2 : bool}
\]
\[
\dfrac{\Gamma \vdash e_1 : num}{\Gamma \vdash -e_1 : num}
\]
\[
\dfrac{\Gamma \vdash e_1 : string \Gamma \vdash e_2 : \tau}{\Gamma \vdash e_1 + e_2 : string}
\]
\[
\dfrac{\Gamma \vdash e_1 : bool \Gamma \vdash e_2 : bool}{\Gamma \vdash e_1 relop e_2 : bool}
\]
\[
\dfrac{\Gamma \vdash e_1 : bool}{\Gamma \vdash NOTe_1 : bool}
\]
\subsection{Scope rules}
Scope rules are where the users variables are visible. In our language there are three kind of scopes: local scope, global scope and function scope. A variable is visible in the specific scope, if can be referenced to. Two variables of the same name, can't be in the same scope. The local variables are declared inside blocks of code, where the blocks are marked with \{ \}. In the example in listing \ref{lst:example} the variable degrees is declared locally in the code block Setup, and it can't be used in other code blocks unless it is nested inside of the Setup block, it could e.g. be used in a if-loop in the Setup block. 

\begin{lstlisting}[caption={Example of local scoping rules},  xleftmargin=.2\textwidth, label={lst:example}]
Setup{
	num degrees;
	degrees = 90;
	
	Tank.forward(degrees);
}
\end{lstlisting}

The parameters declared in a function, is visible in the function scope and can be used just as local variables for the function. The parameters can't be masked by declaring new local variables in the function, since the value of the parameters can't be stored. The parameters can't be named the same as the local- and global variables. 

When a variable is declared in the global scope, it can be used in all of the other functions and code blocks. When a variable is used, it will first search for it in the local scope, if it is not found in the local scope, it will search the in the global scope. In listing \ref{lst:example1} Codeblock1 uses the global variable, where Codeblock2 uses a local variable with the same name as the global variable, but the local variable will be used.


\begin{lstlisting}[caption={Example of global scoping rules},  xleftmargin=.2\textwidth, label={lst:example1}]
Num number = 2; /* Declared globally */

Codeblock1{
	5 + number; /* Will use the global variable number */
}

Codeblock2{
	Num number = 5; /* Locally declared variable */
	5 + number; /* Will use the global variable number */
}
\end{lstlisting}

\chapter{Semantics}
This chapter provides a formal description of the language semantics. The chapter uses techniques from the book \textit{Transitions and Trees} \cite{Huttel}.
 \section{Syntactic categories}
 To simplify the presentation of the semantics of our language, syntactic categories have been used. The syntactic categories are based on the grammer found in section \ref{sec:Grammar}. A collection of metavariables are presented in the following paragraphs which will be used throughout the chapter to present the type system and the operational semantics.
 
 \begin{math}
 e \in \textbf{Expr} - Expressions \newline
 S \in \textbf{Stmt} - Statement\newline
 n \in \textbf{Num} - Numerals\newline
 b \in \textbf{Bool} - Boolean\ Literal\newline
 B \in \textbf{Block} - Block \newline %sure about this??
 tx \in \textbf{Txt} - Txt\ Literal\newline
 t \in \textbf{Type} - Num,\ Bool\ and\ Txt\ types\newline
 x \in \textbf{var} - Variable name \newline
 f \in \textbf{Func} - Function name \newline
 a \in \textbf{Act} - Action name \newline
 D_a \in \textbf{ActDcl} - Action\ declaration\newline
 D_f \in \textbf{FuncDcl} - Function\ declaration\newline
 D_v \in \textbf{VarDcl} - Gobal\ variable\ declaration\newline
 \end{math}
 
 \section{Formation rules}
 Missing intro!
 
\begin{math}
	B ::= \{ \ D_v  \ S \ \}
	\newline
	Stmt ::= \ x = e \ | \ if \ e_1 \ B_1 \ else \ B_2 \ \newline | \ Repeat \ While(e_1) \ B \ | \ Repeat \ B \ While \ (e_2) \ | \ Return \ e \ | \ skip
	\newline
	%Exprs ::= \ Expr \ op \ Exprs \ | \ \epsilon
	%\newline
	%Expr ::= \ ( \ - \ | \ NOT \ )? \ e 
	%\newline
	D_a ::= \ a(S) \ B \ D_a \ | \epsilon 
	\newline
	D_f ::= \ f(S) \ B \ D_f \ | \epsilon 
	\newline
	D_v ::= \tau \ x \ D_v \ | \epsilon 
	\newline
\end{math}
 
 \section{Semantic Functions}
 The purpose of the semantics functions is interpret syntactic elements to semantic elements. The semantic functions used in our language will be described in this section. 
  
  \subsection{Numeral Literals}
  The numbers literal in our language will be Numerals, which will be interpreted to real numbers by means of the semantic function: 
  
  \begin{math}
  \mathcal{N}: \textbf{Num} \rightarrow \mathbb{R}
  \end{math}
  
  Using this function, numerals as 
  \begin{math}
    \mathcal{N}
  \end{math}[\underline{5}] and 
  \begin{math}
    \mathcal{N}
  \end{math}[\underline{5.36}] will be mapped to the corresponding values 5 and 5.36. 
  
  
  \subsection{Text Literals}
  A Text literal is a sequence of symbols and characters in UTF-8(Unicode Transformation Format 8-bit) except the delimiter ("). The sequence of symbols and characters must be within the delimiter, for example "Hello world!". 
  
  %\begin{math}
  %txl \in \textbf{txtL} = (") \newline
  %tx \in \textbf{Txt} = (") \ (U)^* \ (")\ \newline
  %U \in \ {UTF-8}
  %\end{math}
  
  Text Literal are interpreted as string elements Text, by means of the following:
  
  \begin{math}
  	\tau : \textbf{Txt} \ \rightarrow \ \textbf{txtL} \newline
  	As \ an \ example: \ \tau("Insert \ text \ here") \ \rightarrow \ Insert \ text \ here
  \end{math}
  
  \subsection{Boolean Literals}
  The Boolean literals depict whether the expression is evaluated to true or false. The symbol for true is \begin{math} \top \end{math}, and the symbol for false is \begin{math} \bot \end{math} from the set of values from \textbf{bool} = {True, False}.
  
  %\begin{math}
  	%\beta : Bool \rightarrow bool
  %\end{math}
  
  %The semantic function above can be used to evaluate the semantic value of a boolean, take \begin{math} x \ is \ evaluated \ by \ the \ function \ \beta,  \end{math} as an example:
  
  %\[ \beta(x) =
    %\begin{cases}
      %\top       & \quad \text{if } x \text{ is true}\\
      %\bot  & \quad \text{if } x \text{ is false}\\
    %\end{cases}
  %\]
  
  
  \section{Environment Store Model}
  The environment store model describes how variables are bound to a storage during the execution of programs. The variables are bound to a storage-call, where the storage-cell contains the value of the variable. Storage-cells are also called \textit{locations}, the set of locations is denoted \textbf{Loc}. In short the environment store model describes how variables are stored at locations and what values can be found at the locations.
  
  The variable environment is a function that will tell what storage location a variable is bound to. Variable environments  is the set of partial functions  from the variable to their location, as shown in the following equation:
  
  \begin{math}  
	 env_v \in \boldsymbol{EnvV} = \boldsymbol{Var} \cup \{ next \} \rightharpoonup \ \boldsymbol{Loc}
  \end{math}
  
  The partial function above shows us how a variable or the set \{ next \} is bound to a location. The \textit{next} element is pointing to the next available location in memory.
  Let l be an arbitrary element of \textbf{Loc} and always assume that \textbf{Loc} = \begin{math} \mathbb{N}. \end{math} The function \textbf{new} found below, will return the successor for every location by defining \textbf{new} as: \textbf{new} l = l + 1.
  
  \begin{math}
	  \boldsymbol{new} : \ \boldsymbol{Loc} \ \rightarrow \ \boldsymbol{Loc}
  \end{math}
  
  Let \begin{math}env_v\end{math} be an arbitrary element of the partial function \textbf{EnvV}. To update the environment the update notation \begin{math}env_v [x \mapsto v] \end{math} is used. 
  
  \[ env^{'}_v(y) =
      \begin{cases}
        env_v(y)       & \quad \text{if } y \not= x\\
        l  & \quad \text{if } y = x\\
      \end{cases}
    \]
      
  A partial function \textbf{Sto} is defined below with an arbitrary element sto.
  
  \begin{math}
	  sto \ \in \boldsymbol{Sto} \ = \ \boldsymbol{Loc} \rightharpoonup \ \boldsymbol{Value}
  \end{math}
  
  For updating the store sto \begin{math} \in \end{math} \textbf{Sto} the update notation \begin{math} sto[l \mapsto v] \end{math} will be used. A location and a value is needed to be able to update sto.
  
  \[ sto^{'}(l^{'}) =
    \begin{cases}
      sto(l)       & \quad \text{if } l^{'} \not= l\\
      v  & \quad \text{if } l^{'} = l\\
    \end{cases}
  \]
  
  
  
  
  \section{Type system}
  THIS SHALL BE MOVED!!!
	\[
	[NUM] \quad
	\dfrac{}{\Gamma \vdash n ::= Num}
	\]
	 
	\[
	[BOOL] \quad
	\dfrac{}{\Gamma \vdash b ::= Bool}
	\]
	
  	\[
  	[TXT] \quad
  	\dfrac{}{\Gamma \vdash tx ::= Txt}
  	\]
  	
  \section{Operational semantic}
  MISSING INTRO! We should write about the smallstep- and bigstep semantics ?
  
  \subsection{Blocks}
    \[
	  [BLOCK]
	  \dfrac{\langle D_v, \ E_v \rangle \ \rightarrow_{Dv} \ \langle E_v^{'} \rangle \qquad E_v^{'} \ \vdash \ \langle S, \ st \rangle \ \rightarrow_S \ st^{'}}{E_v \ \vdash \ \langle begin \ D_v \ S \ end, \ st \rangle \ \rightarrow_B \ st^{'}}
	  \]
  
  \subsubsection{Declarations}
  	\[
	[EMPTY-VARDCL] \quad
	\dfrac{}{\langle\epsilon, \ E_v\rangle \rightarrow_{Dv} E_v}
	\]
    	
   	\[
   	[VARDCL] \quad
   	\dfrac{ \langle D_v, \ E_v[x \mapsto l]\rangle \ \rightarrow_{Dv} \ \langle E_v^{'} \rangle }{ \langle \ \tau \ x; \ D_v,\ E_v \rangle \rightarrow_{Dv} \ \langle E_v^{'} \rangle }
   	\qquad \ \ l = E_v(next)
   	\]
    	
   	\[
   	[EMPTY-ACTDCL] \quad
   	\dfrac{}{E_v \ \vdash \ \langle \epsilon, E_a \rangle \ \rightarrow_{Da} \ E_a}
   	\]
    	
    	
  	\[
   	[ACTDCL] \quad
   	\dfrac{E_v \ \vdash \langle D_a, \ E_a[a \ \mapsto (S, \ (x_1 .. x_n) \ E_v)] \rangle \rightarrow_Da \ E_a^{'}}{E_v \ \vdash \ Action \ a(x_1 .. x_n) \ is \ S; \ D_a \ E_a \ \rightarrow_{Da} \ E_a^{'}}
   	\]
    	
   	\[
   	[EMPTY-FUNCDCL] \quad
   	\dfrac{}{E_v \ \vdash \langle \epsilon; \ D_f \rangle \ \rightarrow_{Df} \ E_f}
   	\]
   	
   	\[
   	[FUNCDCL] \quad
   	\dfrac{E_v \vdash \langle D_f, \ E_f[f \ \mapsto (S, \ x_1 .. x_n, \ E_v)] \rangle \rightarrow_{Df} E_f^{'}}{E_v \vdash \ \langle Function \ f(x_1 .. x_2) \ is \ S; \ D_f, \ E_f \rangle \ \rightarrow_{Df} \ E_f^{'}}
   	\]
   	\subsection{Statements}
   	
   	\subsection{Expressions}
   	
   	\[
   	[PAR-EXPR] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e, \ st> \rightarrow_e (v, \ st^{'}}{E_v, \ E_a, \ E_f \vdash <(e), \ st> \rightarrow_e \ (v, \ st^{'})}
   	\]
   	
   	\subsection{Arithmetic Expressions}
   	
   	\[
   	[ASM-EXPR] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <a_1, \ st> \rightarrow_{e} (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <a_2, \ st^{''}> \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \vdash <a_1 \ op \ a_2, st> \rightarrow_{e} (v, st^{'})}
   	\]
 	\begin{math}
 	op \ \in \ \{ \ +, \ -, \ * \ \} \newline
   	v \ = \ v_1 \ + \ v_2 \newline
   	v \ = \ v_1 \ - \ v_2 \newline
   	v \ = \ v_1 \ * \ v_2
   	\end{math}
   	
   	\[
   	[DIV-EXPR] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <a_1, \ st> \rightarrow_{e} (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <a_2, \ st^{''}> \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \vdash <a_1 \ op \ a_2, st> \rightarrow_{e} (v, st^{'})}
   	\]
   	\begin{math}
   	op \ \in \ \{ \ /, \ \% \ \} \ | v \not= \ 0 \newline 
   	v \ = \ v_1 \ / \ v_2 \newline
   	v \ = \ v_1 \ \% \ v_2
   	\end{math}   	   	   	

   	\subsection{Boolean Expressions}
   	\[
   	[EXPR^{IS=}_{\ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1
   	\ IS= e_2, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]
   	\begin{math}
   	v_1 \ = \ v_2 
   	\end{math}

   	\[
   	[EXPR^{IS=}_{\ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1
   	\ IS= e_2, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \not= \ v_2
   	\end{math}


   	\[
   	[EXPR^{NOT=}_{\ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ NOT= e_2, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \not= \ v_2
   	\end{math}   	
   	

   	\[
   	[EXPR^{NOT=}_{\ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ NOT= e_2, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ = \ v_2
   	\end{math}   	
   	
   	
   	\[
   	[EXPR^{\ >}_{\ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ > e_2, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ > \ v_2
   	\end{math}   	
   	
   	\newcommand{\exprtrans}[5][E_v, E_a,E_f]{#1\vdash \langle #2, #3 \rangle \mathrel{\to_e} (#4 , #5)}
   	
   	\[
   	[EXPR^{\ >}_{\ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ > e_2, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \not> \ v_2
   	\end{math}   
   	
   	\[
   	[EXPR^{\ <}_{\ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ < e_2, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ < \ v_2
   	\end{math}   	
   	

   	\[
   	[EXPR^{\ <}_{\ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ < e_2, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \not< \ v_2
   	\end{math}
   	
   	\[
   	[EXPR^{\ >=}_{\ \ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ >= e_2, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \ge \ v_2
   	\end{math}   	
   	

   	\[
   	[EXPR^{\ >=}_{\ \ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ >= e_2, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \ngeq \ v_2
   	\end{math}
   	
   	\[
   	[EXPR^{\ <=}_{\ \ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ <= e_2, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \le \ v_2
   	\end{math}   	
   	

   	\[
   	[EXPR^{\ <=}_{\ \ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (v_1, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (v_2, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ <= e_2, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]
	\begin{math}
   	v_1 \ \nleq \ v_2
   	\end{math}
   	
   	\[
   	[EXPR^{\ \ !}_{\ \ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <v, \ st> \rightarrow_e (\top, st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <!v, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]  	  	

   	\[
   	[EXPR^{\ \ !}_{\ \ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <v, \ st> \rightarrow_e (\bot, st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <!v, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]
   	
   	
   	\[
   	[EXPR^{\ AND}_{\ \ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (\top, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (\top, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ AND \ e_2, \ st> \ \rightarrow_e (\top, \ st^{'})}
   	\]  	
   	
   	\[
   	[EXPR^{\ AND}_{\ \ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e, \ st> \rightarrow_e (\bot, \ st) }{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ AND \ e_2, \ st> \ \rightarrow_e (\bot, \ st)}
   	\]
   	
   	
   	\[
   	[EXPR^{\ OR}_{\ \ \top}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e, \ st> \rightarrow_e (\top, \ st) }{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ OR \ e_2, \ st> \ \rightarrow_e (\top, \ st)}
   	\]
   	
   	\[
   	[EXPR^{\ OR}_{\ \ \bot}] \quad
   	\dfrac{E_v, \ E_a, \ E_f \vdash <e_1, \ st> \rightarrow_e (\bot, st^{''}) \qquad E_v, \ E_a, \ E_f \vdash <e_2, \ st^{''} \rightarrow_e (\bot, \ st^{'})}{E_v, \ E_a, \ E_f \ \vdash \ <e_1 \ OR \ e_2, \ st> \ \rightarrow_e (\bot, \ st^{'})}
   	\]  	
   	
   	